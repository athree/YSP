2014/10/27

23:28
没有必要在服务器端维持一张终端的IP和端口的记录，并通过UDP来进行动态的维护，这样服务器端压力较大；

这种情况是考虑短信延迟很大的情况下来进行对照选择的；

讨论短信的延迟；

2014/10/29

17:23
数据按结构体形式组织并可按字节数组的形式相互转换以达到网际传输的效果；

22:39
加入循环荣誉码的相关类；

2014/10/31

15:00
加UDP相关通信方法；查询新加类与现有类之间的访问访问方法；

///////////////////////////////////////////////////
考试耽误进程
///////////////////////////////////////////////////
2014/11/5

10:31
中心通过短信方式提醒终端来发起向中心的UDP连接，短信下发可以通过短信猫或者第三发API进行二次开发，
但是考虑到性能和本项目的要求，没有必要使用第三方API；

2014/11/6

16:10
更行定时器类，用于心跳检测或者轮训终端在线情况
看心跳是由谁发起和维护的

封装UDP类，去除静态方法的调用，通过实例化来构造一对一的UDP服务
整体的类-实例封装，可以方便不论是并行还是串行的操作

2014/11/7
11:36
将UDP的监听和各种初始化转移到构造函数，数据的接收和发送通过send和receive函数来处理，
函数中操作报文解析，数据库存储和转移数据到web前端

14:55
CRC校验和从什么地方开始到CRC之前结束
这里姑且认为CRC校验是从帧头之后开始到CRC之前，即对于第一报文（长帧会有后续报文），字节
数组8~24字节进行校验
对于长帧，处理完第一报文后，后续的报文校验是从0~（BUS_FRAME_MINLEN+dataLen+2）-3===其中两位校验和不需校验

2014/11/8

9:14
接受到帧的处理过程
先转换为结构体-》判断是否为消息帧（帧头是否为XYDTU）-》CRC校验-》判断消息方向合法性-》数据帧处理

                                               接收到data（两个字节数组，一个第一报文base，一个动态开辟根据第一报文的长度external）
					
					      短帧                                              长帧

				    处理base                                               while循环接收到指定长度（根据external申请）
					                                                          

																			  处理external
15:02
设置多个标志位，分别标识有数据要发送（udpsendflag），有数据已接受(udprecvflag)，有什么数据要发送(sendmsgtype)，
有什么数据要接受(recvmsgtype)
21:33
对报文判断的方法重复调用以获得相应的大类型，小类型
为接收的数据申请的空间都是根据数据的具体大小恰好申请的，这里若出现问题做后续讨论

22:38
对于接收到的数据包先转换为结构体，然后在进行分析，这里若存在问题，后期讨论

心跳包的类型编码默认为0x33(由于这里没有给定)，不区分子类型，数据区填充暂不考虑，后续补充

2014/11/9
10:59
默认数据帧中的datalen为数据域的长度，在协议中没有明确给出，没有明确的还有除loopback类之外的其他消息类型和心跳具体

15:42
测试UDP误包率的程序，通过定时发送心跳测试，加入了CRC校验，报文类型检测

18：:55
心跳包格式尚未给出，心跳的具体处理情况暂时不考虑从  帧识别通过SWITCH

2014/11/10

9:30
数据包总是出现一个误包，分别测试20   1000   5000包数据，都会出现一次

16：22
由于每次通信之前服务器端为获取终端endpoint，都会发送一个不符合条件的空帧，被误检为误包

2014/11/15

22:05
多线程对共享变量的访问，不论lock(this)还是lock(object),都无所谓，只要确定锁定的内容是否
属于同一对象（面向对象），或者同一实体（面向过程）
lock不能锁定栈变量，因为会装箱，多次装箱不是同一个对象，所以这里考虑将所有的需要共享的
标志变量开到堆中/可以考虑用链表

2015/11/17

23:20
添加前后台交互，多线程死掉

2014/11/18
15:13
交互调试成功，更改共享量（shared）的初始顺序，主要是之前没有送达数据，由于单方面加锁为同步

16:12
增加超时报错机制
不论使用何种总网络，均采用一主多从，按照应答方式进行通信，当前一个请求的响应消息未返回或
未超时时，主站不能再次发起请求----这就需要在应用层进行过滤

21:32
以太网协议包装RS485协议，重叠部分有何必要？

2014/11/20

15:21
对多字节的整型数据，采用little-endian，即高序字节存储在起始地址
上述摘自协议对字节序存储的定义，但是存在矛盾，后续解释明显为big-endian，结合
下面帧解释，决定对字节序采取little-endian，即低序字节存储在起始地址

所有类型的数据包按帧类型分别建类，每类中在对子类型做相应的方法，组包和拆包放到同一个类中

所有的组包方法，数据段单独通过分类子方法实现，返回数据段的字节序，再用另外一个函数接收并完后完整的组包，
具体讨论分包，结构体附属字段的填充和CRC

2014/11/21
10:26
preparedata 中调用subfunc的方法，结合mergemsg方法完成包的组装
handledata 中调用subfunc的方法，完成包的拆解

2014/11/23
22:07
组包函数在包外就组好数据段，传入packetization()方法，在调用不同的方法组装成不同的数据帧，
如果数据域的长度超多8，那么重新申请空间组装（相对于在方法开始申请固定的数据域）
data是否需要重新开辟空间指定8字节大小，这样复制是否有问题----mergedata（）方法中

C#中各种参数类型，传递存在问题，实在不行就不分过程了

2014/11/24

**************************************************************************************************
16:41                                                                                          ***
纠正组帧方法，当数据域中的数据小于8时也不需要填充，有多少算多少，由datalen控制                 ***
使用结构体和字节数组转换的方法，结构体中的字节数组可以接受大于8的数据组，但是转换的过程中      ***
是只会截取前八个字节，如果去掉data的限制，那么转换后出现乱码错误；                             ***
如果是不足八个的情况,那么就有多少算多少==前提条件：在结构体最开始就已经申请了对应空间8个字节   ***
后期只不过是向其中填充一部分     这里看之后能否可以改善   只要传递地址就好了                   ***
**************************************************************************************************

2014/11/25
传入参数为类类型，则为引用参数；若为其他int byte ushort struct等则为值类型，若作回调，需加ref或者out

2014/11/26
9:45
网络连接为非托管资源，必须手动的回收，stop加close

2014/11/27

20:11
A、组织下设数据的方法接收上面传来的<string , string>对,第一个string为操作单元编码的字符串形式(ushort),
第二个string为textbox的值,相应数据类型的字符串格式

B 对于数据类型中数组类型,前台和通信交互的时候，比如236操作单元对应的是float[5],那么接收web的表示为236A/
236B....236E   

2014/11/28

9:15
一次通信通信请求必须有固定的出口
设置两个数据字典，一个索引操作单元类型，一个索引数组类型的操作单元的长度
*******************************************************************************************
***   1、读来解析数据完成后写到类中并存入数据库                                         ***
***   2、下设的时候接受DICT并依次翻译到字节数组                                         ***
***   类型编码：0-uchar;                                                                ***
***			    1-ushort;                                                               ***
***				2-float;                                                                ***
***				3-datetime;                                                             ***
***				4-char[];                                                               ***
***				5-uchar[];																***
***				6-ushort[];                                                             ***
***				7-float[];																***
*******************************************************************************************

ushort BanReDaiStart_T; 		//伴热带采样前开始时刻
这个变量在数据字典中被更改名字不同于WEB

2014/11/29
21:54
数据字典建立完成，后期需要检查错误
现在使用的是：
             若为数组，那么值存放的是数组的个数；
			 若为混合数组和单类，那么值存放的是混合类型的长度；
待检查完成后：
             修正呼和数组的字典值存放均衡为长度或者个数

2014/11/30

10:48
发来的数据单元字典都需要加前缀，方便区分各种情况
所有的数据类型可大致分为三类：
O:单类型数据;例如（ushort ， uchar ， float ， datetime）
S:数组类型；例如（float[] , char[] , uchar[] , ushort[]）
X:混合类型；例如（以上类型的混合）

2014/12/3

16:04
固定类型或者单一数组类型可以通过数据单元 ，数据类型（以编码）， 数据长度解决问题
混合类型数据也可以指定字典的值为特定结构体或者组织类型，在拆分，但由于混合类型数据较少，
考虑不做封装，直接分情况特定处理
对于单类型字符串或者是混合类型的操作单元，给定第一个数据单元号之后，整个操作单元的数据
根据长度和混合类型直接提取

数据字典使用时需先构造出一个且只需一个实例

2014/12/4

21:17
读写文件和读缓存的过程排除在读写配置框架之外，原因：交互比较多

2014/12/6
15:53
添加对具体数据帧类型的结构体后要先考虑为结构体赋值，才能getdata()
完成所有发送编码

23:08
完成的发送是按照图示例子组合，即过长数据添加到结构体之外一起发送！
注：如果按文字意思，是先发送结构体在发送数据域

数据包接收分类：分包报文和单报文   考虑两种报文的处理（根据数据长度判断）
分包报文关系到发送机制的重改
这里首先按单报文考虑
接收到报文之后，首先对数据字节流判长度，如果小于最小报文，则丢弃；
如果等于最小报文长度，则转化为结构体；
如果大于最小报文长度，则去最小报文长度转换为结构体，然后后面作为数据流处理

发送和接受的都有可能是长帧

2014/12/07
16:03
为了方便组帧中数据长度容易得到，在获取数据域是均采用list数据结构组织，然后转为数组
点击调试时，发送短信使得DTU上线，并发送上线包以及开始心跳，服务器接收到上线包之后前台提示

首先将共享变量设置为静态的，可处理单一连接对象情况，方便简单

考虑数据帧检查和数据帧解析中用到发送帧并解析获取消息的地方能否换成新定义的Compare结构体
                                                        （是否可以为方便初始化，封装成类）
暂且忽略check和handle中对接受数据的重复拆分，如果想提高这里的效率将check和handle封装一下，
处理成检验和处理的对，在封装中进行一次分解

移位运算符运算之前都会将操作数转换为 int？？？

2014/12/09
23:44
检测到无法访问的代码 GetValue()
检查msghandle()方法   其中的下标和取值是否对应

2014/12/10

23:40
完成读数据单元的请求和响应配合，写出测试用例，测试存在问题，sendmsg函数检测不到shared中的remotepoint
的被赋值，考虑是否为多线程访问不了静态共享变量，应该不是，其他测试没有没问题

2014/12/11
20:24
framecheck（）方法中if-else结构存在问题，如果从开始轮寻，有一个错误的那么就会导致函数弹出
这里的错误获取列表没有多大的意义，只有有一个错误都要返回帧检测不通过，而请求重发，所以结构也可以
看需求而定
成功发送读取操作单元数据帧，并完成测试

检测出一个问题：误将long当做4个字节处理，用到的地方要修改为8

执行状态字大于一个字节的情况还没有测试
需完成或之后上述测试，及多线程的lock，并完成在出错情况下的交互（考虑出错最多重新请求错去一次或者原帧重发）
并完成其他类型帧处理及硬件测试    SIM卡及电源调试 上线

2014/12/12
16:50
帧内和帧外都需要CRC校验
发送短帧和发送长帧、接受短帧和长帧测试完成，未完成错误帧测试（在断掉客户端的情况下测试，使用原始数据）
测试返回错误代码是存在问题，客户端和服务器都修改了IP，服务器端修改了请求 ， 客户端修改了default

2014/12/13

10:10
完成错误帧测试
超时机制：在发送完成之后就置位超时机制，如果固定时间内没有在recv中关计时，那么超时响应
在IMServerUDP中继承超时函数，在send中和recv中开启和关闭，达到定时效果

23:54
发送后定时检测完成，如果两个分钟内没有接受到返回值，那么说明掉线，采取措施，通过继承方法实现

2014-12-14

16:06
完成WriteUnit()方法的响应处理
返回的dictionary<ushort , ushort>其中 第一个参数在没有具体要求的情况下，使用编号保存
23:02
完成除文件和缓冲区操作之外的处理
问题：将所有自己组织的ushort、int、long、float、double等和byte[]之间的转换变为库函数处理

2014-12-16

21:02
读取文件的循环过程，使用的是goto语句

writefile在组包之前就打开文件描述符，在文件传输之后关闭文件描述符，文件描述符会传入struct
如果不确定文件描述符被系统的回收，那么就在最开始读出所有文件数据到内存，然后分包下发

为了获取writefile过程中组包从文件读到什么位置，将结构体修改为ref，在结构体中加参数做返回用
为了writefile修改，是否影响其他过程 讨论

long为8字节的错误还未处理完成；
在置位发送、接收、和接收完成的情况下，线程开启可能会出现所想范围外的情况！比如：想让接收线程先启动，
但可能置位后接收线程后启动而在没有接收到情况下检测到姐收完成标志位

14:44
读文件和写文件的过程中的错误全部归结到AfterSend方法最后处理

写文件如果重复，在接收完成之后才覆盖是由下位机处理；
读写文件的中间发生错误，是否判错续传未实现

2014-12-18
15:51
loopback方法上位机需要的是在发送大文件之前进行调用，测试链路通信程度，固定几个标定值，从大到小往上发，
轮训返回帧
消息队列发送出去的请求依次入队，接收到返回帧从队头比较，匹配之后清除相应队列项，每个入队的消息加定时器，
在一定时间轮询队列，如果超时没有响应，则清除队列

2014-12-26
21:31
使用deque处理通信中的队列，不清零的入队和出队不会造成对头的溢出，因为每当处理到_head为3时，就会自动清零；
可以理解为微软的机制；

23014-12-26
11:03
sendmsg已改，packetzation封装一下，独立线程接收放进队列
recvfrom均是指定远端终结点来接收，统一接受数据不能统一接受远端终结点
更改协议帧格式，添加msgid项目，byte类型，用来对应发送和接受数据
byte类型最大值为255即256个数，溢出自动归零，在packetzation中定义静态变量，停留内存，默认队列中不超过256
21：30
哈希表无法按元素取出，遍历的情况下只能是用来DictionaryEntry循环foreach，但foreach循环是在锁定对象的情况下，
遍历，假若改变foreach的对象，那么会异常，只能用到dictionary在for结构下

2014-12-27
16:12
receivefrom由于不能明确指定远端终结点，需要轮训，存在问题
可以通过异常的方式轮训，或者尝试异步接受的方式

2014-12-29
21:10
封装一层发送和封装两层发送都是一样的，再定义一层结构体封装packet返回的字节数组（RS485协议）和编号
防止编号与数据帧脱离，不在校验范围之内（最初想法是字节对其结构体，组织编号和RS485）,在packet中返回
编号与原RS485字节数组（含编码），返回的结构体中编号用来标记计时和缓存，而解析中的编号从framecheck中得到，
framecheck将原只返回执行代码封装到结构体，添加编号（直接在校验中截取）

错误纠正：是在typeofframe中返回上述结构体

aftersend还需修改和编号相关  handledata中analysis

2014-12-30
9:58
对于普通的短帧直接处理，对于分包发送的帧，判断出来之后先开辟编号指定的缓冲区，并在接到后续帧的情况下
不断追加   【要想这样实现就得添加事先判断是否一帧接收完】

读写文件按长帧多包统一处理，即追加

设定文件缓冲区是只给定了指针，静态实例化的时候，也只有指针 ，不断更新指针指向的内容，这里会不会被CLR
处理，如果会被处理，可直接给定静态空间
数据字典中条目不可变，装箱不可返回
2015-01-01
17:49
写文件的时候如果发送的文件和接收的文件数据不统一，按照返回的响应帧中的数据长度偏移累加和发送
上述问题在写文件中同样存在
读取的字节数如何动态的变化？？？
文件名的转换都是long为中间体，byte[] <==> long <==>  string

2015-01-03
15:32
目前认为只有在发送文件的时候才会发包
packetization方法中的执行错误代码表
errorcode              explain
   1                preparedata-packetzation:错误子代码！
   2                preparedata-packetzation:数据帧外层类型存在错误！
   3                preparedata-packetization:组好的原始帧中插入帧编码存在错误！
对于一帧多包的情况，添加后续包到发送队列（即调用addrequire方法）在aftersend中，而更新缓冲列表（即index_obj）
在addrequire中

2015-01-11
23:25
完成读写操作单元的测试

2015-01-12
17:12
数据字典unittypedict更改为0-11种类型，unitlendict更改为操作单元对对应类型字节长度，所有的数组全部组织成相
应的类
22:49
完成前台和通信的两种的数据字典的转化，并合并完成

2015-01-13
9：13
测试获取文件信息单元正常
10:48
测试获取错误代码单元正常

2015-01-14
16:44
完成读文件测试，长文件和短文件均可以完成
为了测试注释了超时检测功能

2015-01-16
22:26
读操作单元添加后续增加的类

2015-01-18
15：55
心跳包单独定义格式和开设专门的套接口处理，因为心跳的并发量比较大，对套接口的压力尤其是若使用原始的协议格式，
数据包的编码容量的冗余会不好控制，所以单独处理，心跳包不进行CRC校验
分两个线程处理心跳计时队列，可能出现访问冲突（同于发送超时）且如果定义为无符号的数，可能由于延迟出现从0
左溢出，变为正数，所以这里修改为有符号dictionary<byte , short>

2015-01-26
16:08
修改原始分立的IP和PORT字典，建立设备号为索引，IPendpoint为值的数据字典，用以维护下端站点，每次更新或添加这个数据字典
对于可能存在的终端的IP和PORT更新的情况，在心跳包检测处理的方法中进行更新

2015-01-29
9：:5
由于采用了大类，即一个页面一个类组织，当请求的操作单元的信息存在错误的时候，采用查类填充正确的单元，再映射到数据库
（建立映射表扩展和更改起来也麻烦可以两张表，但查表麻烦；可以一张表但扩展麻烦,处理：为每一个类写一个方法，方法中switch-case
处理操作单元到类成员的操作，对于多个类一起组织的使用hashtable记录，并不断添加）
当请求的操作单元无错误的时候，就直接字节数组到类的转换在映射到数据库